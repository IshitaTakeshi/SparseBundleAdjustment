def calcImgProj(a[5], qr0[4], v[3], t[3], M[3]):
    L = sqrt(1.0-v[0]*v[0]-v[1]*v[1]-v[2]*v[2]);

    R[0] = L*qr0[0] - v[0]*qr0[1] - v[1]*qr0[2] - v[2]*qr0[3]
    R[1] = L*qr0[1] + v[0]*qr0[0] + v[1]*qr0[3] - v[2]*qr0[2]
    R[2] = L*qr0[2] + v[1]*qr0[0] + v[2]*qr0[1] - v[0]*qr0[3]
    R[3] = L*qr0[3] + v[2]*qr0[0] + v[0]*qr0[2] - v[1]*qr0[1]

    P[0] = + R[0]*M[0] - R[3]*M[1] + R[2]*M[2]
    P[1] = + R[3]*M[0] + R[0]*M[1] - R[1]*M[2]
    P[2] = - R[2]*M[0] + R[1]*M[1] + R[0]*M[2]
    P[3] = + R[1]*M[0] + R[2]*M[1] + R[3]*M[2]

    U[0] = + R[0]*P[0] + R[1]*P[3] + R[2]*P[2] - R[3]*P[1] + t[0]
    U[1] = + R[0]*P[1] - R[1]*P[2] + R[2]*P[3] + R[3]*P[0] + t[1]
    U[2] = + R[0]*P[2] + R[1]*P[1] - R[2]*P[0] + R[3]*P[3] + t[2]

    n[0] = (a[0] * U[0] + a[4] * U[1]) / U[2] + a[1]
    n[1] = (a[0] * a[3] * U[1]) / U[2] + a[2]
    return n

def calc_image_projection(a, qr0, v, t, m):
    A = qr0[0]
    q = qr0[1:]

    L = np.sqrt(1.0-np.dot(v, v))
    r = L * A + v * A + np.cross(v, q)
    D = L * A - np.dot(v, q)
    p = D * m + np.cross(r, m)
    u = np.cross(r, p) + D * p + np.dot(r, m) * r + t

    n[0] = (a[0] * u[0] + a[4] * u[1]) / u[2] + a[1]
    n[1] = (a[0] * a[3] * u[1]) / u[2]        + a[2]



def calcImgProjFullR(a[5], qr0[4], t[3], M[3], n[2]):

    Q = [
        [- qr0[1], - qr0[2], - qr0[3]],
        [+ qr0[0], - qr0[3], + qr0[2]],
        [+ qr0[3], + qr0[0], - qr0[1]],
        [- qr0[2], + qr0[1], + qr0[0]],
    ]

    u = np.dot(Q, M)

    u[0] = - qr0[1]*M[0] - qr0[2]*M[1] - qr0[3]*M[2]
    u[1] = + qr0[0]*M[0] - qr0[3]*M[1] + qr0[2]*M[2]
    u[2] = + qr0[3]*M[0] + qr0[0]*M[1] - qr0[1]*M[2]
    u[3] = - qr0[2]*M[0] + qr0[1]*M[1] + qr0[0]*M[2]

    b[0] = - qr0[1]*u[0] + qr0[0]*u[1] - qr0[3]*u[2] + qr0[2]*u[3] + t[0]
    b[1] = - qr0[2]*u[0] + qr0[3]*u[1] + qr0[0]*u[2] - qr0[1]*u[3] + t[1]
    b[2] = - qr0[3]*u[0] - qr0[2]*u[1] + qr0[1]*u[2] + qr0[0]*u[3] + t[2]

    n[0] = (a[0]*b[0] + a[4]*b[1] + a[1]*b[2]) / b[2]
    n[1] = (a[0]*a[3]*b[1] + a[2]*b[2]) / b[2]
    return n
